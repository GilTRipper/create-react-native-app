diff --git a/CHANGELOG.md b/CHANGELOG.md
deleted file mode 100644
index 396b7a43cdced7ace37274d3144735183f37411e..0000000000000000000000000000000000000000
diff --git a/android/build.gradle b/android/build.gradle
index 36757f7a7c73bfc9d4aa436c952c083dc4661ff9..a08ad76e8b6e050fb2e7c9b9bb5e0ac99ad6a129 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -3,9 +3,10 @@ buildscript {
   // This avoids unnecessary downloads and potential conflicts when the library is included as a
   // module dependency in an application project.
   if (project == rootProject) {
-    repositories {
-      google()
-      mavenCentral()
+      repositories {
+        google()
+        mavenCentral()
+        gradlePluginPortal()
     }
 
     dependencies {
@@ -26,8 +27,54 @@ def getExtOrIntegerDefault(name) {
   return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties['ReactNativeNetInfo_' + name]).toInteger()
 }
 
+def isNewArchitectureEnabled() {
+  return project.hasProperty("newArchEnabled") && project.newArchEnabled == "true"
+}
+
+def resolveReactNativeDirectory() {
+  def reactNativeLocation = getExtOrInitialValue("REACT_NATIVE_NODE_MODULES_DIR", null)
+  if (reactNativeLocation != null) {
+    return file(reactNativeLocation)
+  }
+
+  // monorepo workaround
+  // react-native can be hoisted or in project's own node_modules
+  def reactNativeFromProjectNodeModules = file("${rootProject.projectDir}/../node_modules/react-native")
+  if (reactNativeFromProjectNodeModules.exists()) {
+    return reactNativeFromProjectNodeModules
+  }
+
+  def reactNativeFromNodeModulesWithRNCNetInfo = file("${projectDir}/../../react-native")
+  if (reactNativeFromNodeModulesWithRNCNetInfo.exists()) {
+    return reactNativeFromNodeModulesWithRNCNetInfo
+  }
+
+  throw new Exception(
+          "[react-native-netinfo] Unable to resolve react-native location in " +
+                  "node_modules. You should add project extension property (in app/build.gradle) " +
+                  "`REACT_NATIVE_NODE_MODULES_DIR` with path to react-native."
+  )
+}
+
+def getReactNativeMinorVersion() {
+  def REACT_NATIVE_DIR = resolveReactNativeDirectory()
+
+  def reactProperties = new Properties()
+  file("$REACT_NATIVE_DIR/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }
+
+  def REACT_NATIVE_VERSION = reactProperties.getProperty("VERSION_NAME")
+  def REACT_NATIVE_MINOR_VERSION = REACT_NATIVE_VERSION.startsWith("0.0.0-") ? 1000 : REACT_NATIVE_VERSION.split("\\.")[1].toInteger()
+
+  return REACT_NATIVE_MINOR_VERSION
+}
+
+
 apply plugin: 'com.android.library'
 
+if (isNewArchitectureEnabled()) {
+  apply plugin: 'com.facebook.react'
+}
+
 android {
   compileSdkVersion getExtOrIntegerDefault('compileSdkVersion')
 
@@ -45,10 +92,21 @@ android {
   defaultConfig {
     minSdkVersion getExtOrIntegerDefault('minSdkVersion')
     targetSdkVersion getExtOrIntegerDefault('targetSdkVersion')
+    buildConfigField("boolean", "IS_NEW_ARCHITECTURE_ENABLED", isNewArchitectureEnabled().toString())
+  }
+  sourceSets {
+    main {
+        if (isNewArchitectureEnabled()) {
+            java.srcDirs += ['src/newarch']
+        } else {
+            java.srcDirs += ['src/oldarch']
+        }
+      }
   }
   lintOptions{
     abortOnError false
   }
+
 }
 
 repositories {
@@ -72,6 +130,9 @@ repositories {
 
 dependencies {
   //noinspection GradleDynamicVersion
-  implementation 'com.facebook.react:react-native:+'
-
+  if (isNewArchitectureEnabled() && getReactNativeMinorVersion() < 71) {
+    implementation project(":ReactAndroid")
+  } else {
+    implementation 'com.facebook.react:react-native:+'
+  }
 }
\ No newline at end of file
diff --git a/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoModule.java b/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoModuleImpl.java
similarity index 82%
rename from android/src/main/java/com/reactnativecommunity/netinfo/NetInfoModule.java
rename to android/src/main/java/com/reactnativecommunity/netinfo/NetInfoModuleImpl.java
index 626134aa031a99058997b4901fcd80a3eb1ad774..f174872cc1408e6f418b340fcef8d727a67f5c7a 100644
--- a/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoModule.java
+++ b/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoModuleImpl.java
@@ -9,13 +9,11 @@ package com.reactnativecommunity.netinfo;
 import android.os.Build;
 import com.facebook.react.bridge.Promise;
 import com.facebook.react.bridge.ReactApplicationContext;
-import com.facebook.react.bridge.ReactContextBaseJavaModule;
 import com.facebook.react.bridge.ReactMethod;
 import com.facebook.react.module.annotations.ReactModule;
 
 /** Module that monitors and provides information about the connectivity state of the device. */
-@ReactModule(name = NetInfoModule.NAME)
-public class NetInfoModule extends ReactContextBaseJavaModule implements AmazonFireDeviceConnectivityPoller.ConnectivityChangedCallback {
+public class NetInfoModuleImpl implements AmazonFireDeviceConnectivityPoller.ConnectivityChangedCallback {
     public static final String NAME = "RNCNetInfo";
 
     private final ConnectivityReceiver mConnectivityReceiver;
@@ -23,8 +21,7 @@ public class NetInfoModule extends ReactContextBaseJavaModule implements AmazonF
 
     private int numberOfListeners = 0;
 
-    public NetInfoModule(ReactApplicationContext reactContext) {
-        super(reactContext);
+    public NetInfoModuleImpl(ReactApplicationContext reactContext) {
         // Create the connectivity receiver based on the API level we are running on
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
             mConnectivityReceiver = new NetworkCallbackConnectivityReceiver(reactContext);
@@ -35,7 +32,7 @@ public class NetInfoModule extends ReactContextBaseJavaModule implements AmazonF
         mAmazonConnectivityChecker = new AmazonFireDeviceConnectivityPoller(reactContext, this);
     }
 
-    @Override
+
     public void initialize() {
         mConnectivityReceiver.register();
         mAmazonConnectivityChecker.register();
@@ -54,13 +51,8 @@ public class NetInfoModule extends ReactContextBaseJavaModule implements AmazonF
     public void invalidate() {
         mAmazonConnectivityChecker.unregister();
         mConnectivityReceiver.unregister();
-        mConnectivityReceiver.hasListener = false;
     }
 
-    @Override
-    public String getName() {
-        return NAME;
-    }
 
     @ReactMethod
     public void getCurrentState(final String requestedInterface, final Promise promise) {
@@ -72,14 +64,14 @@ public class NetInfoModule extends ReactContextBaseJavaModule implements AmazonF
         mConnectivityReceiver.setIsInternetReachableOverride(isConnected);
     }
 
-    @ReactMethod
+
     public void addListener(String eventName) {
         numberOfListeners++;
         mConnectivityReceiver.hasListener = true;
     }
 
-    @ReactMethod
-    public void removeListeners(Integer count) {
+
+    public void removeListeners(double count) {
         numberOfListeners -= count;
         if (numberOfListeners == 0) {
             mConnectivityReceiver.hasListener = false;
diff --git a/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoPackage.java b/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoPackage.java
index fcd4a5e6dc0626aef32ac9db6c2d4b22283beec7..1bf0b623b5b0ae882550184fb1e81ac1844f5a63 100644
--- a/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoPackage.java
+++ b/android/src/main/java/com/reactnativecommunity/netinfo/NetInfoPackage.java
@@ -1,34 +1,46 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
 package com.reactnativecommunity.netinfo;
 
-import com.facebook.react.ReactPackage;
-import com.facebook.react.bridge.JavaScriptModule;
+import androidx.annotation.Nullable;
 import com.facebook.react.bridge.NativeModule;
 import com.facebook.react.bridge.ReactApplicationContext;
-import com.facebook.react.uimanager.ViewManager;
-import java.util.Arrays;
+import com.facebook.react.module.model.ReactModuleInfo;
+import com.facebook.react.module.model.ReactModuleInfoProvider;
+import com.facebook.react.TurboReactPackage;
+
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
-public class NetInfoPackage implements ReactPackage {
-    @Override
-    public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
-        return Arrays.<NativeModule>asList(new NetInfoModule(reactContext));
-    }
+public class NetInfoPackage extends TurboReactPackage {
 
-    // Deprecated from RN 0.47
-    public List<Class<? extends JavaScriptModule>> createJSModules() {
-        return Collections.emptyList();
-    }
+  @Nullable
+  @Override
+  public NativeModule getModule(String name, ReactApplicationContext reactContext) {
+          if (name.equals(NetInfoModuleImpl.NAME)) {
+              return new NetInfoModule(reactContext);
+          } else {
+              return null;
+          }
+  }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
-        return Collections.emptyList();
-    }
+  @Override
+  public ReactModuleInfoProvider getReactModuleInfoProvider() {
+           return () -> {
+                    final Map<String, ReactModuleInfo> moduleInfos = new HashMap<>();
+                    boolean turboModulesEnabled = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
+                    moduleInfos.put(
+                                    NetInfoModuleImpl.NAME,
+                                    new ReactModuleInfo(
+                                                    NetInfoModuleImpl.NAME,
+                                                    NetInfoModuleImpl.NAME,
+                                                    false, // canOverrideExistingModule
+                                                    false, // needsEagerInit
+                                                    true, // hasConstants
+                                                    false, // isCxxModule
+                                                    turboModulesEnabled // isTurboModule
+                                            ));
+                    return moduleInfos;
+                };
+  }
 }
diff --git a/android/src/newarch/com/reactnativecommunity/netinfo/NetInfoModule.java b/android/src/newarch/com/reactnativecommunity/netinfo/NetInfoModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..61e44c4a4f775cd464916224ef4f786976f4bc16
--- /dev/null
+++ b/android/src/newarch/com/reactnativecommunity/netinfo/NetInfoModule.java
@@ -0,0 +1,51 @@
+package com.reactnativecommunity.netinfo;
+
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+
+public class NetInfoModule extends NativeRNCNetInfoSpec {
+
+    private NetInfoModuleImpl implementation;
+
+    NetInfoModule(ReactApplicationContext context) {
+        super(context);
+        implementation = new NetInfoModuleImpl(context);
+    }
+
+    @Override
+    public String getName() {
+        return NetInfoModuleImpl.NAME;
+    }
+
+    @ReactMethod
+    public void getCurrentState(final String requestedInterface, final Promise promise) {
+        implementation.getCurrentState(requestedInterface, promise);
+    }
+
+    @ReactMethod
+    public void configure(ReadableMap config) {
+        // iOS only
+    }
+
+    @ReactMethod
+    public void addListener(String eventName) {
+        implementation.addListener(eventName);
+    }
+
+    @ReactMethod
+    public void removeListeners(double count) {
+        implementation.removeListeners(count);
+    }
+    
+    @Override
+    public void onCatalystInstanceDestroy() {
+        implementation.onCatalystInstanceDestroy();
+    }
+
+    @Override
+    public void initialize() {
+        implementation.initialize();
+    }
+}
diff --git a/android/src/oldarch/com/reactnativecommunity/netinfo/NetInfoModule.java b/android/src/oldarch/com/reactnativecommunity/netinfo/NetInfoModule.java
new file mode 100644
index 0000000000000000000000000000000000000000..4738d63b7d9bc7fade21e7af094af5da18155d55
--- /dev/null
+++ b/android/src/oldarch/com/reactnativecommunity/netinfo/NetInfoModule.java
@@ -0,0 +1,59 @@
+
+
+package com.reactnativecommunity.netinfo;
+
+import com.facebook.react.bridge.NativeModule;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import java.util.Map;
+import java.util.HashMap;
+import com.facebook.react.bridge.ReadableMap;
+
+public class NetInfoModule extends ReactContextBaseJavaModule {
+
+    private NetInfoModuleImpl implementation;
+
+    NetInfoModule(ReactApplicationContext context) {
+        super(context);
+        implementation = new NetInfoModuleImpl(context);
+    }
+
+    @Override
+    public String getName() {
+        return NetInfoModuleImpl.NAME;
+    }
+
+    @ReactMethod
+    public void getCurrentState(final String requestedInterface, final Promise promise) {
+        implementation.getCurrentState(requestedInterface, promise);
+    }
+
+    @Override
+    public void onCatalystInstanceDestroy() {
+        implementation.onCatalystInstanceDestroy();
+    }
+
+
+    @Override
+    public void initialize() {
+        implementation.initialize();
+    }
+
+    @ReactMethod
+    public void addListener(String eventName) {
+        implementation.addListener(eventName);
+    }
+
+    @ReactMethod
+    public void configure(ReadableMap config) {
+        // iOS only
+    }
+
+    @ReactMethod
+    public void removeListeners(double count) {
+        implementation.removeListeners(count);
+    }
+}
diff --git a/ios/RNCNetInfo.mm b/ios/RNCNetInfo.mm
new file mode 100644
index 0000000000000000000000000000000000000000..6b816480d9db3cd27ea3effcba50c0a33f391f91
--- /dev/null
+++ b/ios/RNCNetInfo.mm
@@ -0,0 +1,284 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#import "RNCNetInfo.h"
+#import "RNCConnectionStateWatcher.h"
+
+#ifdef RCT_NEW_ARCH_ENABLED
+#import "RNCNetInfoSpec.h"
+#endif
+
+#include <ifaddrs.h>
+#include <arpa/inet.h>
+
+#if !TARGET_OS_TV && !TARGET_OS_MACCATALYST && !TARGET_OS_VISION
+#import <CoreTelephony/CTCarrier.h>
+#import <CoreTelephony/CTTelephonyNetworkInfo.h>
+#endif
+#import <SystemConfiguration/CaptiveNetwork.h>
+
+
+#import <React/RCTAssert.h>
+#import <React/RCTBridge.h>
+#import <React/RCTEventDispatcher.h>
+
+#ifdef RCT_NEW_ARCH_ENABLED
+@interface RNCNetInfo () <RNCConnectionStateWatcherDelegate, NativeRNCNetInfoSpec>
+#else
+@interface RNCNetInfo () <RNCConnectionStateWatcherDelegate>
+#endif
+
+@property (nonatomic, strong) RNCConnectionStateWatcher *connectionStateWatcher;
+@property (nonatomic) BOOL isObserving;
+@property (nonatomic) NSDictionary *config;
+
+@end
+
+@implementation RNCNetInfo
+
+#pragma mark - Module setup
+
+RCT_EXPORT_MODULE()
+
+// We need RNCReachabilityCallback's and module methods to be called on the same thread so that we can have
+// guarantees about when we mess with the reachability callbacks.
+- (dispatch_queue_t)methodQueue
+{
+  return dispatch_get_main_queue();
+}
+
++ (BOOL)requiresMainQueueSetup
+{
+  return YES;
+}
+
+#pragma mark - Lifecycle
+
+- (NSArray *)supportedEvents
+{
+  return @[@"netInfo.networkStatusDidChange"];
+}
+
+- (void)startObserving
+{
+  self.isObserving = YES;
+}
+
+- (void)stopObserving
+{
+  self.isObserving = NO;
+}
+
+- (instancetype)init
+{
+  self = [super init];
+  if (self) {
+    _connectionStateWatcher = [[RNCConnectionStateWatcher alloc] initWithDelegate:self];
+  }
+  return self;
+}
+
+- (void)dealloc
+{
+  self.connectionStateWatcher = nil;
+}
+
+#pragma mark - RNCConnectionStateWatcherDelegate
+
+- (void)connectionStateWatcher:(RNCConnectionStateWatcher *)connectionStateWatcher didUpdateState:(RNCConnectionState *)state
+{
+  if (self.isObserving) {
+    NSDictionary *dictionary = [self currentDictionaryFromUpdateState:state withInterface:NULL];
+    [self sendEventWithName:@"netInfo.networkStatusDidChange" body:dictionary];
+  }
+}
+
+#pragma mark - Public API
+
+RCT_EXPORT_METHOD(getCurrentState:(nullable NSString *)requestedInterface resolve:(RCTPromiseResolveBlock)resolve
+                  reject:(__unused RCTPromiseRejectBlock)reject)
+{
+  RNCConnectionState *state = [self.connectionStateWatcher currentState];
+  resolve([self currentDictionaryFromUpdateState:state withInterface:requestedInterface]);
+}
+
+
+RCT_EXPORT_METHOD(configure:(NSDictionary *)config)
+{
+    self.config = config;
+}
+
+#pragma mark - Utilities
+
+// Converts the state into a dictionary to send over the bridge
+- (NSDictionary *)currentDictionaryFromUpdateState:(RNCConnectionState *)state withInterface:(nullable NSString *)requestedInterface
+{
+  NSString *selectedInterface = requestedInterface ?: state.type;
+  NSMutableDictionary *details = [self detailsFromInterface:selectedInterface withState:state];
+  bool connected = [state.type isEqualToString:selectedInterface] && state.connected;
+  if (connected) {
+    details[@"isConnectionExpensive"] = @(state.expensive);
+  }
+
+  return @{
+    @"type": selectedInterface,
+    @"isConnected": @(connected),
+    @"details": details ?: NSNull.null
+  };
+}
+
+- (NSMutableDictionary *)detailsFromInterface:(nonnull NSString *)requestedInterface withState:(RNCConnectionState *)state
+{
+  NSMutableDictionary *details = [NSMutableDictionary new];
+  if ([requestedInterface isEqualToString: RNCConnectionTypeCellular]) {
+    details[@"cellularGeneration"] = state.cellularGeneration ?: NSNull.null;
+    details[@"carrier"] = [self carrier] ?: NSNull.null;
+  } else if ([requestedInterface isEqualToString: RNCConnectionTypeWifi] || [requestedInterface isEqualToString: RNCConnectionTypeEthernet]) {
+    details[@"ipAddress"] = [self ipAddress] ?: NSNull.null;
+    details[@"subnet"] = [self subnet] ?: NSNull.null;
+    #if !TARGET_OS_TV && !TARGET_OS_OSX && !TARGET_OS_MACCATALYST && !TARGET_OS_VISION
+      /*
+        Without one of the conditions needed to use CNCopyCurrentNetworkInfo, it will leak memory.
+        Clients should only set the shouldFetchWiFiSSID to true after ensuring requirements are met to get (B)SSID.
+      */
+      if (self.config && self.config[@"shouldFetchWiFiSSID"]) {
+        details[@"ssid"] = [self ssid] ?: NSNull.null;
+        details[@"bssid"] = [self bssid] ?: NSNull.null;
+      }
+    #endif
+  }
+  return details;
+}
+
+- (NSString *)carrier
+{
+#if (TARGET_OS_TV || TARGET_OS_OSX || TARGET_OS_MACCATALYST || TARGET_OS_VISION)
+  return nil;
+#else
+  CTTelephonyNetworkInfo *netinfo = [[CTTelephonyNetworkInfo alloc] init];
+  CTCarrier *carrier = [netinfo subscriberCellularProvider];
+  return carrier.carrierName;
+#endif
+}
+
+- (NSString *)ipAddress
+{
+  NSString *address = @"0.0.0.0";
+  struct ifaddrs *interfaces = NULL;
+  struct ifaddrs *temp_addr = NULL;
+  int success = 0;
+  // retrieve the current interfaces - returns 0 on success
+  success = getifaddrs(&interfaces);
+  if (success == 0) {
+    // Loop through linked list of interfaces
+    temp_addr = interfaces;
+    while (temp_addr != NULL) {
+      if (temp_addr->ifa_addr->sa_family == AF_INET) {
+        NSString* ifname = [NSString stringWithUTF8String:temp_addr->ifa_name];
+        if (
+          // Check if interface is en0 which is the wifi connection on the iPhone
+          // and the ethernet connection on the Apple TV
+          [ifname isEqualToString:@"en0"] ||
+          // Check if interface is en1 which is the wifi connection on the Apple TV
+          [ifname isEqualToString:@"en1"]
+        ) {
+          // Get NSString from C String
+          char str[INET_ADDRSTRLEN];
+          inet_ntop(AF_INET, &((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr, str, INET_ADDRSTRLEN);
+          address = [NSString stringWithUTF8String:str];
+        }
+      }
+
+      temp_addr = temp_addr->ifa_next;
+    }
+  }
+  // Free memory
+  freeifaddrs(interfaces);
+  return address;
+}
+
+- (NSString *)subnet
+{
+  NSString *subnet = @"0.0.0.0";
+  struct ifaddrs *interfaces = NULL;
+  struct ifaddrs *temp_addr = NULL;
+  int success = 0;
+  // retrieve the current interfaces - returns 0 on success
+  success = getifaddrs(&interfaces);
+  if (success == 0) {
+    // Loop through linked list of interfaces
+    temp_addr = interfaces;
+    while (temp_addr != NULL) {
+      if (temp_addr->ifa_addr->sa_family == AF_INET) {
+        NSString* ifname = [NSString stringWithUTF8String:temp_addr->ifa_name];
+        if (
+          // Check if interface is en0 which is the wifi connection on the iPhone
+          // and the ethernet connection on the Apple TV
+          [ifname isEqualToString:@"en0"] ||
+          // Check if interface is en1 which is the wifi connection on the Apple TV
+          [ifname isEqualToString:@"en1"]
+        ) {
+          // Get NSString from C String
+          char str[INET_ADDRSTRLEN];
+          inet_ntop(AF_INET, &((struct sockaddr_in *)temp_addr->ifa_netmask)->sin_addr, str, INET_ADDRSTRLEN);
+          subnet = [NSString stringWithUTF8String:str];
+        }
+      }
+
+      temp_addr = temp_addr->ifa_next;
+    }
+  }
+  // Free memory
+  freeifaddrs(interfaces);
+  return subnet;
+}
+
+#if !TARGET_OS_TV && !TARGET_OS_OSX && !TARGET_OS_MACCATALYST
+- (NSString *)ssid
+{
+  NSArray *interfaceNames = CFBridgingRelease(CNCopySupportedInterfaces());
+  NSDictionary *SSIDInfo;
+  NSString *SSID = NULL;
+  for (NSString *interfaceName in interfaceNames) {
+    // CNCopyCurrentNetworkInfo is deprecated for iOS 13+, need to override & use fetchCurrentWithCompletionHandler
+    SSIDInfo = CFBridgingRelease(CNCopyCurrentNetworkInfo((__bridge CFStringRef)interfaceName));
+    if (SSIDInfo.count > 0) {
+        SSID = SSIDInfo[@"SSID"];
+        if ([SSID isEqualToString:@"Wi-Fi"] || [SSID isEqualToString:@"WLAN"]){
+          SSID = NULL;
+        }
+        break;
+    }
+  }
+  return SSID;
+}
+
+- (NSString *)bssid
+{
+  NSArray *interfaceNames = CFBridgingRelease(CNCopySupportedInterfaces());
+  NSDictionary *networkDetails;
+  NSString *BSSID = NULL;
+  for (NSString *interfaceName in interfaceNames) {
+        // CNCopyCurrentNetworkInfo is deprecated for iOS 13+, need to override & use fetchCurrentWithCompletionHandler
+      networkDetails = CFBridgingRelease(CNCopyCurrentNetworkInfo((__bridge CFStringRef)interfaceName));
+      if (networkDetails.count > 0)
+      {
+          BSSID = networkDetails[(NSString *) kCNNetworkInfoKeyBSSID];
+          break;
+      }
+  }
+  return BSSID;
+}
+#endif
+
+#ifdef RCT_NEW_ARCH_ENABLED
+- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {
+  return std::make_shared<facebook::react::NativeRNCNetInfoSpecJSI>(params);
+}
+#endif
+
+@end
diff --git a/package.json b/package.json
index 7e842a20ee95a4c2604999a1dc35dbe9671a0296..d84cccce4bdd2e716a000585367d9bc1801f67f3 100644
--- a/package.json
+++ b/package.json
@@ -48,6 +48,7 @@
     "network info"
   ],
   "peerDependencies": {
+    "react": "*",
     "react-native": ">=0.59"
   },
   "dependencies": {},
@@ -121,5 +122,13 @@
       "yarn eslint --fix",
       "git add"
     ]
+  },
+  "codegenConfig": {
+    "name": "RNCNetInfoSpec",
+    "type": "modules",
+    "jsSrcsDir": "src/internal",
+    "android": {
+      "javaPackageName": "com.reactnativecommunity.netinfo"
+    }
   }
 }
diff --git a/src/__tests__/eventListenerCallbacks.spec.ts b/src/__tests__/eventListenerCallbacks.spec.ts
index 4ba58e9b197df5d1fb92da5b7a9f80da71537f4a..9f87df7b06c3ba8ce0549c33a454d8d920d4a2c1 100644
--- a/src/__tests__/eventListenerCallbacks.spec.ts
+++ b/src/__tests__/eventListenerCallbacks.spec.ts
@@ -32,7 +32,7 @@ beforeAll(() => {
 
 describe('@react-native-community/netinfo listener', () => {
   describe('Event listener callbacks', () => {
-    it('should call the listener on listening', done => {
+    it('should call the listener on listening', (done) => {
       const listener = jest.fn();
       NetInfo.addEventListener(listener);
 
@@ -42,7 +42,7 @@ describe('@react-native-community/netinfo listener', () => {
       }, 0);
     });
 
-    it('should call the listener on listening with multiple listeners', done => {
+    it('should call the listener on listening with multiple listeners', (done) => {
       const listener1 = jest.fn();
       const listener2 = jest.fn();
       NetInfo.addEventListener(listener1);
@@ -303,7 +303,7 @@ describe('@react-native-community/netinfo listener', () => {
           ];
         }
 
-        dataProvider().forEach(testCase => {
+        dataProvider().forEach((testCase) => {
           it(testCase.description, () => {
             NetInfo.configure(testCase.configuration);
 
diff --git a/src/__tests__/fetch.spec.ts b/src/__tests__/fetch.spec.ts
index 4b56e4f788f814b2473fa9d22076d419624a003a..b7906594b984dba362a704e85636f431397ca683 100644
--- a/src/__tests__/fetch.spec.ts
+++ b/src/__tests__/fetch.spec.ts
@@ -69,7 +69,7 @@ describe('@react-native-community/netinfo fetch', () => {
         ];
       }
 
-      dataProvider().forEach(testCase => {
+      dataProvider().forEach((testCase) => {
         it(testCase.description, () => {
           mockNativeModule.getCurrentState.mockResolvedValue(
             testCase.expectedConnectionInfo,
@@ -131,7 +131,7 @@ describe('@react-native-community/netinfo fetch', () => {
         ];
       }
 
-      dataProvider().forEach(testCase => {
+      dataProvider().forEach((testCase) => {
         it(testCase.description, () => {
           mockNativeModule.getCurrentState.mockResolvedValue(
             testCase.expectedConnectionInfo,
@@ -193,7 +193,7 @@ describe('@react-native-community/netinfo fetch', () => {
         ];
       }
 
-      dataProvider().forEach(testCase => {
+      dataProvider().forEach((testCase) => {
         it(testCase.description, () => {
           mockNativeModule.getCurrentState.mockResolvedValue(
             testCase.expectedConnectionInfo,
@@ -255,7 +255,7 @@ describe('@react-native-community/netinfo fetch', () => {
         ];
       }
 
-      dataProvider().forEach(testCase => {
+      dataProvider().forEach((testCase) => {
         it(testCase.description, () => {
           mockNativeModule.getCurrentState.mockResolvedValue(
             testCase.expectedConnectionInfo,
@@ -317,7 +317,7 @@ describe('@react-native-community/netinfo fetch', () => {
         ];
       }
 
-      dataProvider().forEach(testCase => {
+      dataProvider().forEach((testCase) => {
         it(testCase.description, () => {
           mockNativeModule.getCurrentState.mockResolvedValue(
             testCase.expectedConnectionInfo,
@@ -361,7 +361,7 @@ describe('@react-native-community/netinfo fetch', () => {
       ];
     }
 
-    dataProvider().forEach(testCase => {
+    dataProvider().forEach((testCase) => {
       it(testCase.description, () => {
         mockNativeModule.getCurrentState.mockResolvedValue(
           testCase.expectedConnectionInfo,
@@ -455,7 +455,7 @@ describe('@react-native-community/netinfo fetch', () => {
         ];
       }
 
-      dataProvider().forEach(testCase => {
+      dataProvider().forEach((testCase) => {
         it(testCase.description, async () => {
           mockNativeModule.getCurrentState.mockResolvedValue(
             testCase.expectedConnectionInfo,
diff --git a/src/internal/NativeRNCNetInfo.ts b/src/internal/NativeRNCNetInfo.ts
new file mode 100644
index 0000000000000000000000000000000000000000..deada41bb0ba34bc002228b238e1ff570b6d903b
--- /dev/null
+++ b/src/internal/NativeRNCNetInfo.ts
@@ -0,0 +1,14 @@
+/* eslint-disable @typescript-eslint/ban-types */
+import type { TurboModule } from 'react-native';
+import { TurboModuleRegistry } from 'react-native';
+
+export interface Spec extends TurboModule {
+  configure: (config: Object) => void;
+  getCurrentState(requestedInterface?: string): Promise<Object>;
+  // Events
+  addListener: (eventName: string) => void;
+  removeListeners: (count: number) => void;
+}
+
+export default TurboModuleRegistry.getEnforcing<Spec>('RNCNetInfo');
+
diff --git a/src/internal/internetReachability.ts b/src/internal/internetReachability.ts
index 757d784a5fe6d0b768a27f94704099f6b013b311..f9940a56c2323c0031155f0355242c702700f87a 100644
--- a/src/internal/internetReachability.ts
+++ b/src/internal/internetReachability.ts
@@ -19,7 +19,8 @@ export default class InternetReachability {
   private _configuration: Types.NetInfoConfiguration;
   private _listener: PrivateTypes.NetInfoInternetReachabilityChangeListener;
   private _isInternetReachable: boolean | null | undefined = undefined;
-  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;
+  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null =
+    null;
   private _currentTimeoutHandle: ReturnType<typeof setTimeout> | null = null;
 
   constructor(
@@ -60,7 +61,8 @@ export default class InternetReachability {
         this._setIsInternetReachable(null);
       }
       // Start a network request to check for internet
-      this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();
+      this._currentInternetReachabilityCheckHandler =
+        this._checkInternetReachability();
     } else {
       // If we don't expect a connection or don't run reachability check, just change the state to "false"
       this._setIsInternetReachable(false);
@@ -98,23 +100,28 @@ export default class InternetReachability {
       timeoutPromise,
       cancelPromise,
     ])
-      .then(
-        (response): Promise<boolean> => {
-          return this._configuration.reachabilityTest(response);
-        },
-      )
-      .then(
-        (result): void => {
-          this._setIsInternetReachable(result);
-          const nextTimeoutInterval = this._isInternetReachable
-            ? this._configuration.reachabilityLongTimeout
-            : this._configuration.reachabilityShortTimeout;
+      .then((response): Promise<boolean> => {
+        return this._configuration.reachabilityTest(response);
+      })
+      .then((result): void => {
+        this._setIsInternetReachable(result);
+        const nextTimeoutInterval = this._isInternetReachable
+          ? this._configuration.reachabilityLongTimeout
+          : this._configuration.reachabilityShortTimeout;
+        this._currentTimeoutHandle = setTimeout(
+          this._checkInternetReachability,
+          nextTimeoutInterval,
+        );
+      })
+      .catch((error: Error | 'timedout' | 'canceled'): void => {
+        if (error !== 'canceled') {
+          this._setIsInternetReachable(false);
           this._currentTimeoutHandle = setTimeout(
             this._checkInternetReachability,
-            nextTimeoutInterval,
+            this._configuration.reachabilityShortTimeout,
           );
-        },
-      )
+        }
+      })
       .catch(
         (error: Error | 'timedout' | 'canceled'): void => {
           if ('canceled' === error) {
diff --git a/src/internal/nativeInterface.ts b/src/internal/nativeInterface.ts
index 8b514f48fb56bad0a1bbff6bc9da87f9c9db51a9..912a903c4ae7618b1526fe637033a66a5de8b559 100644
--- a/src/internal/nativeInterface.ts
+++ b/src/internal/nativeInterface.ts
@@ -28,7 +28,12 @@ If none of these fix the issue, please open an issue on the Github repository: h
  * JavaScript code and the tests
  */
 let nativeEventEmitter: NativeEventEmitter | null = null;
-const nativeInterface = Object.assign(RNCNetInfo, {
+
+export default {
+  configure: RNCNetInfo.configure,
+  addListener: RNCNetInfo.addListener,
+  removeListeners: RNCNetInfo.removeListeners,
+  getCurrentState: RNCNetInfo.getCurrentState,
   get eventEmitter(): NativeEventEmitter {
     if (!nativeEventEmitter) {
       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
@@ -39,5 +44,4 @@ const nativeInterface = Object.assign(RNCNetInfo, {
     /// @ts-ignore
     return nativeEventEmitter;
   },
-});
-export default nativeInterface;
+};
diff --git a/src/internal/nativeInterface.web.ts b/src/internal/nativeInterface.web.ts
index b6652355e3ca2ee61ec89faf2585a06065b53778..41863a4ae459682b43ff87c178556feee1e29206 100644
--- a/src/internal/nativeInterface.web.ts
+++ b/src/internal/nativeInterface.web.ts
@@ -14,12 +14,9 @@ import {DEVICE_CONNECTIVITY_EVENT} from './privateTypes';
 const nativeEventEmitter = new NativeEventEmitter();
 
 // Listen to connectivity events
-RNCNetInfo.addListener(
-  DEVICE_CONNECTIVITY_EVENT,
-  (event): void => {
-    nativeEventEmitter.emit(DEVICE_CONNECTIVITY_EVENT, event);
-  },
-);
+RNCNetInfo.addListener(DEVICE_CONNECTIVITY_EVENT, (event): void => {
+  nativeEventEmitter.emit(DEVICE_CONNECTIVITY_EVENT, event);
+});
 
 export default {
   ...RNCNetInfo,
diff --git a/src/internal/nativeModule.ts b/src/internal/nativeModule.ts
index 206a69a4b1a5ec8579fadef626f10c0294d65c0e..7aff149f169659c13bbf52856aee6f8373050075 100644
--- a/src/internal/nativeModule.ts
+++ b/src/internal/nativeModule.ts
@@ -10,6 +10,16 @@
 import {NativeModules} from 'react-native';
 import {NetInfoNativeModule} from './privateTypes';
 
-const RNCNetInfo: NetInfoNativeModule = NativeModules.RNCNetInfo;
+// React Native sets `__turboModuleProxy` on global when TurboModules are enabled.
+// Currently, this is the recommended way to detect TurboModules.
+// https://reactnative.dev/docs/the-new-architecture/backward-compatibility-turbomodules#unify-the-javascript-specs
+// eslint-disable-next-line @typescript-eslint/ban-ts-comment
+// @ts-ignore
+const isTurboModuleEnabled = global.__turboModuleProxy != null;
+
+const RNCNetInfo: NetInfoNativeModule = isTurboModuleEnabled
+  ? // eslint-disable-next-line @typescript-eslint/no-var-requires
+    require('./NativeRNCNetInfo').default
+  : NativeModules.RNCNetInfo;
 
 export default RNCNetInfo;
diff --git a/src/internal/types.ts b/src/internal/types.ts
index a25ea6e7ee279cb77822360598f84c62920ab58b..8d5f7814da63929b5d4b8219ae04181ebbb3f464 100644
--- a/src/internal/types.ts
+++ b/src/internal/types.ts
@@ -34,7 +34,7 @@ export interface NetInfoConnectedDetails {
 
 interface NetInfoConnectedState<
   T extends NetInfoStateType,
-  D extends Record<string, unknown> = Record<string, unknown>
+  D extends Record<string, unknown> = Record<string, unknown>,
 > {
   type: T;
   isConnected: boolean;
@@ -59,9 +59,8 @@ export interface NetInfoUnknownState {
   isWifiEnabled?: boolean;
 }
 
-export type NetInfoNoConnectionState = NetInfoDisconnectedState<
-  NetInfoStateType.none
->;
+export type NetInfoNoConnectionState =
+  NetInfoDisconnectedState<NetInfoStateType.none>;
 export type NetInfoDisconnectedStates =
   | NetInfoUnknownState
   | NetInfoNoConnectionState;
@@ -87,9 +86,8 @@ export type NetInfoWifiState = NetInfoConnectedState<
     txLinkSpeed: number | null;
   }
 >;
-export type NetInfoBluetoothState = NetInfoConnectedState<
-  NetInfoStateType.bluetooth
->;
+export type NetInfoBluetoothState =
+  NetInfoConnectedState<NetInfoStateType.bluetooth>;
 export type NetInfoEthernetState = NetInfoConnectedState<
   NetInfoStateType.ethernet,
   {
diff --git a/windows/.gitignore b/windows/.gitignore
deleted file mode 100644
index 878f7ba59d11b7df15164c3c5022b750647bf9b0..0000000000000000000000000000000000000000
